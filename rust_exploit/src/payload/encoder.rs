pub struct Encoder {
    key: u8,
}

impl Encoder {
    pub fn new(key: u8) -> Self {
        Self { key }
    }
    
    pub fn encode(&self, data: &[u8]) -> Vec<u8> {
        data.iter().map(|&b| b ^ self.key).collect()
    }
    
    pub fn decode(&self, data: &[u8]) -> Vec<u8> {
        self.encode(data) // XOR is symmetric
    }
    
    pub fn rot13_encode(&self, data: &[u8]) -> Vec<u8> {
        data.iter().map(|&b| {
            if b >= b'a' && b <= b'z' {
                ((b - b'a' + 13) % 26 + b'a')
            } else if b >= b'A' && b <= b'Z' {
                ((b - b'A' + 13) % 26 + b'A')
            } else {
                b
            }
        }).collect()
    }
}

#[no_mangle]
pub extern "C" fn rust_encode(data: *const u8, len: usize, key: u8) -> *mut u8 {
    if data.is_null() {
        return std::ptr::null_mut();
    }
    
    unsafe {
        let slice = std::slice::from_raw_parts(data, len);
        let encoded = Encoder::new(key).encode(slice);
        
        let boxed = encoded.into_boxed_slice();
        Box::into_raw(boxed) as *mut u8
    }
}

#[no_mangle]
pub extern "C" fn rust_free_encoded(ptr: *mut u8) {
    if !ptr.is_null() {
        unsafe {
            let _ = Box::from_raw(ptr);
        }
    }
}
