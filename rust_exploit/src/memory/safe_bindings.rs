use std::ffi::{c_void, CStr};
use libc::{self, size_t};

#[repr(C)]
pub struct SafeMemoryRegion {
    pub base: *mut u8,
    pub size: size_t,
    pub prot: u32,
}

impl SafeMemoryRegion {
    pub fn new(size: size_t) -> Result<Self, std::io::Error> {
        unsafe {
            let ptr = libc::mmap(
                std::ptr::null_mut(),
                size,
                libc::PROT_READ | libc::PROT_WRITE,
                libc::MAP_PRIVATE | libc::MAP_ANONYMOUS,
                -1,
                0,
            );
            
            if ptr == libc::MAP_FAILED {
                return Err(std::io::Error::last_os_error());
            }
            
            Ok(Self {
                base: ptr as *mut u8,
                size,
                prot: libc::PROT_READ | libc::PROT_WRITE,
            })
        }
    }
    
    pub fn protect(&mut self, prot: u32) -> Result<(), std::io::Error> {
        unsafe {
            let result = libc::mprotect(self.base as *mut c_void, self.size, prot as i32);
            if result != 0 {
                return Err(std::io::Error::last_os_error());
            }
            self.prot = prot;
            Ok(())
        }
    }
}

#[no_mangle]
pub extern "C" fn safe_malloc(size: size_t) -> *mut c_void {
    unsafe { libc::malloc(size) }
}

#[no_mangle]
pub extern "C" fn safe_free(ptr: *mut c_void) {
    unsafe { libc::free(ptr) }
}

#[no_mangle]
pub extern "C" fn safe_memcpy(dst: *mut c_void, src: *const c_void, n: size_t) -> i32 {
    unsafe {
        std::ptr::copy_nonoverlapping(src as *const u8, dst as *mut u8, n);
        0
    }
}
